import os
import sys
import time
import shutil
import urllib3
import urllib.request
import requests
import pandas as pd
from datetime import datetime

# Importação para comunicação com Outlook Local
try:
    import win32com.client as win32
except ImportError:
    print("ERRO: Instale a biblioteca pywin32 executando: pip install pywin32")

# Selenium imports
from selenium import webdriver
from selenium.webdriver.edge.service import Service as EdgeService
from selenium.webdriver.edge.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

# --- CONFIGURAÇÕES DE REDE CORPORATIVA ---
os.environ['WDM_SSL_VERIFY'] = '0'
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# --- CONFIGURAÇÕES DO AMBIENTE ---
URL_LISTA_SEATRIUM = "https://seatrium.sharepoint.com/sites/P84P85DesignReview/Lists/P8485_TOPSIDE_DR90_Punch_List/Updated%20View.aspx"
NOME_LISTA_API = "P84/85_TOPSIDE_DR90_Punch_List"

# CAMINHO SINCRONIZADO (Localmente via OneDrive/SharePoint)
# Agora usando o caminho direto da sua máquina para maior performance.
PASTA_DESTINO = r"C:\Users\E797\PETROBRAS\SRGE SI-II SCP85 ES - Planilha_BI_Punches"

CAMINHO_DRIVER_FIXO = r"C:\Users\E797\PycharmProjects\pythonProject\msedgedriver.exe"

# E-mail (O envio será feito via App Outlook Local)
EMAIL_DESTINO = '658b4ef7.petrobras.com.br@br.teams.ms'

# --- DEFINIÇÃO DE COLUNAS PERMITIDAS ---
COLUNAS_DESEJADAS = [
    "DECK No.", "Action Description", "KBR Comment", "Company", "KBR Discipline",
    "Status", "Date Cleared by KBR", "Petrobras Response By", "Petrobras Response Date",
    "Petrobras Response ", "Petrobras Remarks", "Petrobras Discipline",
    "Petrobras Responsible", "Seatrium Remarks", "Zone", "Date Cleared by Petrobras",
    "S3D Item Tags", "Punch No", "KBR Target Date", "Days Since Date Cleared by KBR",
    "Days Since Date Cleared by Seatrium", "Punched by  (Group)",
    "Petrobras Need Operation to close? (Y/N)", "Date Cleared by Petrobras Operation",
    "Petrobras Operation accept closing? (Y/N)", "Is Reopen? (Y/N)",
    "Seatrium Target Date Calculated", "Petrobras Operation Target Date Calculated",
    "Petrobras Target Date Calculated", "Petrobras Target Date",
    "Petrobras Operation Target Date", "Seatrium Target Date"
]


class AutomacaoPunchList:
    def __init__(self):
        self.driver = None
        self.log_sessao = []
        self.mapeamento_colunas = {}

    def registrar_log(self, mensagem):
        timestamp = datetime.now().strftime('%H:%M:%S')
        texto = f"[{timestamp}] {mensagem}"
        print(texto)
        self.log_sessao.append(texto)

    def enviar_via_outlook_app(self, sucesso):
        status = "SUCESSO" if sucesso else "FALHA"
        corpo = f"RELATÓRIO DE EXECUÇÃO CORPORATIVA\nData: {datetime.now().strftime('%d/%m/%Y')}\n\n"
        corpo += "\n".join(self.log_sessao)

        try:
            outlook = win32.Dispatch('outlook.application')
            mail = outlook.CreateItem(0)
            mail.To = EMAIL_DESTINO
            mail.Subject = f"Relatório Automático Punch DR90 - {status}"
            mail.Body = corpo
            mail.Send()
            self.registrar_log("Log enviado via aplicativo Outlook.")
        except Exception as e:
            self.registrar_log(f"Falha ao enviar e-mail via Outlook Desktop: {e}")

    def tratar_dados(self, df):
        self.registrar_log("Limpando e formatando dados...")

        df = df.rename(columns=self.mapeamento_colunas)
        colunas_finais = [c for c in COLUNAS_DESEJADAS if c in df.columns]
        df = df[colunas_finais].copy()

        for col in df.columns:
            df.loc[:, col] = df[col].astype(str)
            df.loc[df[col].str.contains("error", case=False, na=False), col] = ""

            if "Date" in col or df[col].str.contains(r'\d{4}-\d{2}-\d{2}T', na=False).any():
                try:
                    # Converte forçando formato ISO para evitar Warnings
                    df_dt = pd.to_datetime(df[col], errors='coerce', utc=True)
                    mask = df_dt.notna()
                    df.loc[mask, col] = df_dt[mask].dt.strftime('%d/%m/%Y')
                    df.loc[:, col] = df[col].replace(['NaT', 'nan', 'None', 'nan/nan/nan'], "")
                except:
                    continue

        return df

    def obter_mapeamento_colunas(self, session, base_url):
        endpoint = f"{base_url}/_api/web/lists/getbytitle('{NOME_LISTA_API}')/fields"
        try:
            headers = {"Accept": "application/json;odata=verbose"}
            response = session.get(endpoint, headers=headers)
            if response.status_code == 200:
                fields = response.json()['d']['results']
                self.mapeamento_colunas = {f['InternalName']: f['Title'] for f in fields}
                self.registrar_log("Dicionário de colunas sincronizado.")
            else:
                self.registrar_log("Falha ao mapear schema do SharePoint.")
        except Exception as e:
            self.registrar_log(f"Erro no mapeamento: {e}")

    def iniciar_sessao_navegador(self):
        if not os.path.exists(CAMINHO_DRIVER_FIXO):
            self.registrar_log("Driver não encontrado!")
            return

        edge_options = Options()
        edge_options.add_argument("--ignore-certificate-errors")

        try:
            service = EdgeService(executable_path=CAMINHO_DRIVER_FIXO)
            self.driver = webdriver.Edge(service=service, options=edge_options)
            self.driver.get(URL_LISTA_SEATRIUM)

            self.registrar_log("Aguardando login na Seatrium...")
            wait = WebDriverWait(self.driver, 120)
            wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, "[role='grid']")))
            self.registrar_log("Sessão autenticada detectada.")
        except Exception as e:
            self.registrar_log(f"Erro no navegador: {e}")

    def extrair_dados(self):
        self.log_sessao = []
        self.registrar_log("Iniciando ciclo de extração...")
        try:
            cookies = self.driver.get_cookies()
            session = requests.Session()
            session.verify = False

            for cookie in cookies:
                session.cookies.set(cookie['name'], cookie['value'])

            base_site_url = "https://seatrium.sharepoint.com/sites/P84P85DesignReview"
            if not self.mapeamento_colunas:
                self.obter_mapeamento_colunas(session, base_site_url)

            endpoint = f"{base_site_url}/_api/web/lists/getbytitle('{NOME_LISTA_API}')/items?$top=5000"
            headers = {"Accept": "application/json;odata=verbose"}
            response = session.get(endpoint, headers=headers)

            if response.status_code == 200:
                results = response.json().get('d', {}).get('results', [])
                if results:
                    df_raw = pd.json_normalize(results)
                    df_final = self.tratar_dados(df_raw)

                    if not os.path.exists(PASTA_DESTINO):
                        os.makedirs(PASTA_DESTINO)

                    caminho_final = os.path.join(PASTA_DESTINO, "Punch_DR90_TS.xlsx")

                    try:
                        # Salva na pasta sincronizada
                        df_final.to_excel(caminho_final, index=False)
                        self.registrar_log(f"Sucesso: Planilha salva na pasta sincronizada.")
                        self.registrar_log(f"Destino: {caminho_final}")
                        self.enviar_via_outlook_app(True)
                    except PermissionError:
                        self.registrar_log("ERRO: O arquivo Excel está aberto. Feche-o para salvar.")
                else:
                    self.registrar_log("A lista retornou vazia.")
            else:
                raise Exception(f"Erro API SharePoint: {response.status_code}")

        except Exception as e:
            self.registrar_log(f"Falha no ciclo: {e}")
            self.enviar_via_outlook_app(False)

    def executar(self):
        self.iniciar_sessao_navegador()
        if self.driver:
            while True:
                self.extrair_dados()
                print("Próximo ciclo em 5 minutos...")
                time.sleep(300)


if __name__ == "__main__":
    AutomacaoPunchList().executar()